# QAR-MVP — Minimal Prototype of the QAR Architecture

QAR-MVP is the first working prototype of the **QAR (Qazaq Architecture of RISC)** initiative.  
This project demonstrates that Kazakhstan can design and implement its own processor architecture, instruction set subset, and development toolkit using only:

- 1 MacBook Air M2 (8 GB RAM)
- 2 engineers (human + AI collaboration)
- open-source tools (Verilog, Icarus, Go)

The current MVP implements:
- a functional 32-bit register file  
- a functional ALU (ADD, SUB, AND, OR, XOR, SLL, SRL)  
- a minimal RV32I-compatible core capable of executing real instructions  
- an external `program.hex` loader  
- full simulation environment and testbenches  

This is the **first step** toward a sovereign processor ecosystem in Kazakhstan.

---

## Project Structure

qar-mvp/
  docs/               # Documentation (architecture, specifications, reports)
  qar-core/
    rtl/              # Verilog RTL modules (regfile, alu, core)
    sim/              # Testbenches and simulation files
    test/             # Program-level tests (future)
  qar-os/
    boot/             # Bootloader (planned)
    kernel/           # Minimal OS kernel (planned)
    lib/              # Runtime libraries (planned)
  devkit/
    cli/              # CLI tools (assembler, runner) — planned
    web/              # Web UI — planned
  scripts/            # Simulation scripts, build helpers
  program.hex         # Current program executed by the core
  data.hex            # Data memory image consumed by LW/SW

---

## Current Core Capabilities (QAR-Core v0.6)

### Supported Instructions (RV32I subset)
- ADDI, ADD, SUB, AND, OR, XOR, SLL, SRL, LUI, AUIPC
- LW, SW (through streaming valid/ready data memory interface)
- BEQ, BNE, BLT, BGE, BLTU, BGEU
- JAL, JALR
- CSRRW/CSRRS/CSRRC + ECALL/MRET (full trap skeleton with programmable timer/external IRQ)

### Micro-program + Data Memory
- `devkit/examples/irq_demo.qar` programs `mtvec`, `mie`, `mtimecmp`, handles timer + external interrupts, and uses ECALL/MRET to persist counters.
- `devkit/examples/sum_positive.qar` remains available for LW/SW/branch-focused regressions. `data.hex` files continue to be generated by the DevKit CLI for each scenario.

### Execution Model
- Three-stage pipeline (IF → ID → EX) that streams both instruction and data memory transactions over `valid/ready` interfaces, includes single-cycle forwarding, and interlocks on load-use hazards.
- The fetch path owns a two-entry prefetch queue so IMEM keeps issuing while downstream stages drain; IMEM/DMEM bus widths are parameterized via `IMEM_DATA_WIDTH` / `DMEM_DATA_WIDTH` (default 32-bit) for future multi-beat transfers.
- Optional direct-mapped instruction cache (controlled via `ICACHE_ENTRIES`) can service hits without issuing IMEM handshakes, paving the way toward full cache hierarchies in upcoming revisions.
- Configurable interrupt priority (`irqprio` CSR) and software-driven acknowledge pulses (`irqack` CSR outputs) let firmware choose which source preempts and emit explicit timer/external end-of-interrupt strobes—useful for nested IRQ demos.
- Register file exposes two read ports/one write port (x0 hardwired to zero); `default_nettype none` guards plus SymbiYosys harnesses (BMC) cover the regfile.
- CSR/timer subsystem (`mstatus`, `mie`, `mip`, `mtvec`, `mepc`, `mcause`, `mtime`, `mtimecmp`) enables ECALL + timer + external IRQ flows with `MRET` round-trips.

### Simulation Output Example
```
QAR-Core: loading program from program.hex ...
QAR-Core: loading data memory from data.hex ...
=== QAR-Core v0.6 EXECUTION TEST ===
Register x10 = 2 (expected 2)
Register x11 = 1 (expected 1)
Data memory[18] = 2 (expected 2)
Data memory[19] = 1 (expected 1)
Data memory[20] = 0x000001ee (expected 0x000001EE)
Execution test completed.
```

### DevKit CLI (qarsim)

The Go-based `qarsim` tool assembles `.qar` programs (with `.include` directives and `.equ` macro support), generates `program.hex` / `data.hex`, and can launch simulations:

```sh
# Build (assemble) the IRQ demo used by run_core_exec.sh
go run ./devkit/cli build \
  --asm devkit/examples/irq_demo.qar \
  --data devkit/examples/irq_demo.data \
  --imem 128 \
  --dmem 256 \
  --program program.hex \
  --data-out data.hex

# Assemble and immediately run the execution testbench
go run ./devkit/cli run \
  --asm devkit/examples/irq_demo.qar \
  --data devkit/examples/irq_demo.data \
  --imem 128 \
  --dmem 256
```

# Additional Examples
- `devkit/examples/sum_positive.qar` — filters out negative values and exercises JAL/JALR.
- `devkit/examples/mem_copy.qar` — copies a block of words via LW/SW.
- `devkit/examples/branch_demo.qar` — demonstrates the BGE/BGEU flow control.
- `devkit/examples/irq_demo.qar` — sets up `mtvec/mie/mtimecmp`, handles timer + external interrupts, and validates ECALL/MRET flows.

## Tools Required

Install Verilog simulator:
brew install icarus-verilog

Install Go toolchain (for the DevKit CLI):
brew install go

## How to Run Simulations

Each script automatically invokes `go run ./devkit/cli build` to regenerate the correct `program.hex`/`data.hex` (IRQ demo for the execution test, sum-positive for randomized load/store) before compiling with Icarus Verilog.

ALU Test
```sh
./scripts/run_alu.sh
```

## Register File Test
```sh
./scripts/run_regfile.sh
```

## Full Core Execution Test
```sh
./scripts/run_core_exec.sh
```
This builds and runs the `irq_demo` program, checking timer/external interrupts plus ECALL/MRET flow.

## GPIO Demonstration
```sh
./scripts/run_gpio.sh
```
Builds the `gpio_demo` program and runs a dedicated testbench that now showcases interrupt-enabled GPIO inputs: the firmware enables bit-8 interrupt, polls `IRQ_STATUS`, and stores the latched value when the testbench toggles an input.

## UART RS-485 Demo
```sh
./scripts/run_uart.sh
```
Builds the `uart_rs485` program and runs a loopback testbench that exercises the upgraded UART controller with parity + idle gap detection, storing the received bytes plus the idle/TX-empty interrupt snapshot into DMEM.

## Timer / Watchdog Demo
```sh
./scripts/run_timer.sh
```
Builds the `timer_demo` program and runs a testbench that configures the new timer/watchdog peripheral. The firmware proves CMP0 auto-reload and watchdog expiry handling by popping the latched status bits into DMEM for verification.
It also exercises the manual capture registers and PWM outputs so integrators can validate the HAL before wiring timer interrupts into their firmware.

## SPI Loopback Demo
```sh
./scripts/run_spi.sh
```
Builds the `spi_loopback` program and runs a testbench that loops MOSI back into MISO, proving that the new SPI master’s TX/RX FIFOs, chip-select handling, and polling interface work end-to-end by checking the received bytes in DMEM.

## I2C Loopback Demo
```sh
./scripts/run_i2c.sh
```
Builds the `i2c_loopback` firmware and runs a testbench that ties the controller’s SDA output back into its input. The program issues a START followed by two writes and a STOP, then stores the resulting STATUS word into DMEM to verify the new I2C master registers and FIFOs.

## CAN Loopback Demo
```sh
./scripts/run_can.sh
```
Builds the `can_loopback` program and runs a testbench that exercises the CAN controller in loopback mode by transmitting two frames (single-word + double-word payloads), popping them via the new RX FIFO control register, and verifying the IDs/payload words materialize in DMEM.

## Randomized Load/Store Regression
```sh
./scripts/run_random.sh
```
This rebuilds the `sum_positive` program and perturbs its data set to stress the LW/SW path with injected wait states.

## Cache Configuration Regression
```sh
./scripts/run_cache.sh
```
Builds a dedicated loop program plus the `qar_core_cache_tb` harness to run the core with `ICACHE_ENTRIES` enabled, ensuring that the instruction-cache configuration executes correctly while reporting the observed IMEM traffic.

## Formal Check (SymbiYosys)
```sh
sby -f formal/regfile/regfile.sby
```
or

```sh
PATH=$HOME/.local/bin:$PATH sby -f formal/regfile/regfile.sby
```

# Documentation
	•	Architecture specification￼
	•	MVP progress report￼

# Vision

The long-term goal is to establish a sovereign processor, OS, compiler, and hardware ecosystem for the Republic of Kazakhstan, based on QAR — an open and extensible architecture inspired by RISC-V.

# License

This project is currently released under the MIT License.
